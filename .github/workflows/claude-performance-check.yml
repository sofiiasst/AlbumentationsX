name: Claude Performance Analysis

on:
  pull_request:
    types: [opened]
    paths:
      - 'albumentations/augmentations/**/*.py'
      - 'albumentations/core/**/*.py'
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to analyze'
        required: true

jobs:
  performance-analysis:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout PR
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Performance Review
        uses: anthropics/claude-code-action@beta
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          direct_prompt: |
            Analyze this PR specifically for performance implications:

            1. **Algorithmic Complexity**:
               - Identify any O(nÂ²) or worse algorithms that could be optimized
               - Look for unnecessary nested loops

            2. **OpenCV LUT Optimization**:
               - Identify operations that could use cv2.LUT for faster lookup-based transformations
               - Replace pixel-wise operations with LUT when applicable
               - Suggest pre-computed lookup tables for mathematical functions

            3. **OpenCV over Numpy**:
               - Recommend cv2 functions over numpy equivalents where faster
               - Check for correct cv2 flag usage and optimal parameters
               - Identify numpy operations that have cv2 counterparts

            4. **Vectorized Numpy**:
               - Find operations that could be vectorized
               - Identify redundant array copies or allocations
               - Suggest using numpy broadcasting where applicable
               - Replace loops with vectorized operations

            5. **In-place Operations**:
               - Identify opportunities for in-place modifications
               - Suggest safe in-place operations to reduce memory allocations
               - Find unnecessary array copies that could be avoided

            6. **Memory Efficiency**:
               - Identify large temporary arrays
               - Find opportunities to reduce memory footprint
               - Suggest memory-efficient alternatives

            7. **Caching Opportunities**:
               - Identify repeated calculations
               - Suggest memoization where appropriate

            For each finding, provide:
            - Current implementation with complexity analysis
            - Optimized version with benchmarking code
            - Expected performance improvement

            Generate a simple benchmark snippet to compare before/after if significant optimizations are found.
