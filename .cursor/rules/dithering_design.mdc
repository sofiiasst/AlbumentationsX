---
alwaysApply: true
---

# Dithering Transform Design Document

## Overview

Dithering is an intentionally applied form of noise used to randomize quantization error when reducing color depth. It prevents large-scale patterns such as color banding in images by approximating colors not available in the reduced palette through spatial distribution of available colors.

## Core Concepts

### What Dithering Does
- Converts images from higher bit depth to lower bit depth (e.g., grayscale to black/white, 24-bit RGB to 256 colors)
- Reduces quantization artifacts like banding
- Creates perception of more colors than actually present through spatial mixing

### Key Applications in Computer Vision
- Data augmentation for training models on reduced color depth inputs
- Simulating historical/retro imaging conditions
- Preprocessing for certain types of analysis
- Artistic effects and stylization

## Dithering Algorithms to Implement

Based on the Wikipedia article and common usage, we should implement these dithering methods:

### 1. Random Dithering (White Noise)
- **Method**: Add random noise before quantization
- **Pros**: Simple, no patterns
- **Cons**: Grainy appearance
- **Parameters**: `noise_range: tuple[float, float]`

### 2. Ordered Dithering (Bayer Matrix)
- **Method**: Use repeating threshold matrices (Bayer patterns)
- **Common Matrices**:
  - 2x2 Bayer matrix
  - 4x4 Bayer matrix
  - 8x8 Bayer matrix
  - 16x16 Bayer matrix
- **Pros**: Fast, produces regular patterns, good for real-time
- **Cons**: Visible crosshatch patterns
- **Parameters**: `matrix_size: Literal[2, 4, 8, 16]`

### 3. Error Diffusion Dithering
Multiple algorithms that propagate quantization error to neighboring pixels:

#### Floyd-Steinberg (Most Common)
- Error distribution: 7/16 right, 3/16 bottom-left, 5/16 bottom, 1/16 bottom-right
- Most widely used, good balance of quality and speed

#### Jarvis-Judice-Ninke
- 12-pixel error distribution
- Higher quality but slower

#### Stucki
- 12-pixel distribution, different weights
- Good for high-detail images

#### Atkinson
- Distributes only 75% of error (lighter appearance)
- Good for high-contrast images

#### Burkes
- 7-pixel distribution
- Faster than Jarvis but better than Floyd-Steinberg

#### Sierra
- Multiple variants (Sierra, Sierra-2-row, Sierra-Lite)
- Different tradeoffs between quality and speed

#### Parameters for Error Diffusion
- `algorithm: Literal["floyd_steinberg", "jarvis", "stucki", "atkinson", "burkes", "sierra", "sierra_2row", "sierra_lite"]`
- `serpentine: bool = False` (bidirectional scanning to reduce artifacts)

### 4. Pattern Dithering
- **Method**: Use predefined patterns for different gray levels
- **Pros**: Predictable results
- **Cons**: Very visible patterns
- **Parameters**: `pattern_size: int`

### 5. Void-and-Cluster Dithering
- **Method**: Blue-noise dithering that minimizes low-frequency noise
- **Pros**: Visually pleasing, no visible patterns
- **Cons**: More complex to implement
- **Parameters**: `cluster_size: int`

## Implementation Architecture

### Main Transform Class

```python
class Dithering(ImageOnlyTransform):
    """Apply dithering to reduce color depth of images.

    Args:
        method: Dithering algorithm to use
        n_colors: Target number of colors per channel (2 for black/white)
        color_mode: How to handle color images ("rgb", "per_channel", "grayscale")
        error_diffusion_algorithm: Specific algorithm for error diffusion method
        bayer_matrix_size: Size of Bayer matrix for ordered dithering
        serpentine: Use serpentine scanning for error diffusion
        p: Probability of applying transform
    """

    class InitSchema(BaseTransformInitSchema):
        method: Literal["random", "ordered", "error_diffusion", "pattern", "void_cluster"]
        n_colors: int = Field(ge=2, le=256)
        color_mode: Literal["rgb", "per_channel", "grayscale"] = "per_channel"
        error_diffusion_algorithm: Literal["floyd_steinberg", "jarvis", "stucki", "atkinson", "burkes", "sierra", "sierra_2row", "sierra_lite"] = "floyd_steinberg"
        bayer_matrix_size: Literal[2, 4, 8, 16] = 4
        serpentine: bool = False
        noise_range: tuple[float, float] = (-0.5, 0.5)
```

### Functional Implementation Structure

Create `albumentations/augmentations/pixel/dithering_functional.py`:

```python
# Core quantization functions
def quantize_colors(img: np.ndarray, n_colors: int) -> tuple[np.ndarray, np.ndarray]:
    """Quantize image to n colors, return quantized and palette"""

# Individual algorithm implementations
def random_dither(img: np.ndarray, n_colors: int, noise_range: tuple[float, float]) -> np.ndarray:
    """Random noise dithering"""

def ordered_dither(img: np.ndarray, n_colors: int, matrix_size: int) -> np.ndarray:
    """Ordered dithering with Bayer matrix"""

def floyd_steinberg_dither(img: np.ndarray, n_colors: int, serpentine: bool) -> np.ndarray:
    """Floyd-Steinberg error diffusion"""

# ... other error diffusion algorithms ...

def generate_bayer_matrix(size: int) -> np.ndarray:
    """Generate Bayer threshold matrix of given size"""

# Error diffusion kernels as constants
FLOYD_STEINBERG_KERNEL = np.array([
    [0, 0, 7/16],
    [3/16, 5/16, 1/16]
])

JARVIS_KERNEL = np.array([
    [0, 0, 0, 7/48, 5/48],
    [3/48, 5/48, 7/48, 5/48, 3/48],
    [1/48, 3/48, 5/48, 3/48, 1/48]
])

# ... other kernels ...
```

## Key Design Decisions

### 1. Color Handling
- **Grayscale conversion**: Convert to grayscale first, then dither
- **Per-channel**: Dither each RGB channel independently
- **RGB together**: Treat as single color space (for palette-based dithering)

### 2. Data Type Handling
- Use `@float32_io` decorator since dithering works with continuous values
- Input can be uint8 or float32, output maintains input type
- Internal processing in float32 [0, 1] range

### 3. Performance Optimizations
- Pre-generate and cache Bayer matrices
- Use NumPy vectorization where possible
- For error diffusion, consider Numba JIT compilation for inner loops
- Implement serpentine scanning efficiently

### 4. Edge Cases
- Handle image borders correctly in error diffusion (don't propagate outside bounds)
- Ensure n_colors=2 produces proper black/white output
- Handle already-quantized images gracefully

## Testing Strategy

### Unit Tests
1. Test each dithering method independently
2. Verify output has correct number of unique values
3. Test with different image sizes and types
4. Test edge cases (single color images, gradients)

### Visual Tests
1. Create gradient test image to show banding reduction
2. Test on photographic images
3. Compare different algorithms side-by-side

### Parameterized Tests
```python
@pytest.mark.parametrize("method", ["threshold", "random", "ordered", "error_diffusion"])
@pytest.mark.parametrize("n_colors", [2, 4, 16, 256])
@pytest.mark.parametrize("img_dtype", [np.uint8, np.float32])
def test_dithering_methods(method, n_colors, img_dtype):
    # Test implementation
```

## Example Usage

```python
import albumentations as A
import numpy as np

# Create transform
transform = A.Compose([
    A.Dithering(
        method="error_diffusion",
        n_colors=2,  # Black and white
        error_diffusion_algorithm="floyd_steinberg",
        color_mode="grayscale",
        p=1.0
    )
])

# Apply to image
image = np.random.randint(0, 256, (100, 100, 3), dtype=np.uint8)
dithered = transform(image=image)["image"]
```

## Implementation Priority

1. **Phase 1** (Core):
   - Floyd-Steinberg error diffusion (most common)
   - Ordered dithering with Bayer matrix
   - Random dithering

2. **Phase 2** (Extended):
   - Other error diffusion algorithms
   - Serpentine scanning

3. **Phase 3** (Advanced):
   - Void-and-cluster method
   - Pattern dithering
   - Color palette optimization

## References

- Wikipedia: Dither - https://en.wikipedia.org/wiki/Dither
- Floyd-Steinberg dithering algorithm details
- Bayer matrix generation algorithms
- Error diffusion kernel specifications

## Notes for Implementation

- Follow AlbumentationsX coding guidelines (no "Random" prefix, use ranges for parameters)
- Implement in `albumentations/augmentations/pixel/` directory
- Add comprehensive docstrings with visual examples
- Consider creating a separate module if implementation becomes large
- Ensure compatibility with existing pipeline (Compose, etc.)
# Dithering Transform Design Document

## Overview

Dithering is an intentionally applied form of noise used to randomize quantization error when reducing color depth. It prevents large-scale patterns such as color banding in images by approximating colors not available in the reduced palette through spatial distribution of available colors.

## Core Concepts

### What Dithering Does
- Converts images from higher bit depth to lower bit depth (e.g., grayscale to black/white, 24-bit RGB to 256 colors)
- Reduces quantization artifacts like banding
- Creates perception of more colors than actually present through spatial mixing

### Key Applications in Computer Vision
- Data augmentation for training models on reduced color depth inputs
- Simulating historical/retro imaging conditions
- Preprocessing for certain types of analysis
- Artistic effects and stylization

## Dithering Algorithms to Implement

Based on the Wikipedia article and common usage, we should implement these dithering methods:

### 1. Random Dithering (White Noise)
- **Method**: Add random noise before quantization
- **Pros**: Simple, no patterns
- **Cons**: Grainy appearance
- **Parameters**: `noise_range: tuple[float, float]`

### 2. Ordered Dithering (Bayer Matrix)
- **Method**: Use repeating threshold matrices (Bayer patterns)
- **Common Matrices**:
  - 2x2 Bayer matrix
  - 4x4 Bayer matrix
  - 8x8 Bayer matrix
  - 16x16 Bayer matrix
- **Pros**: Fast, produces regular patterns, good for real-time
- **Cons**: Visible crosshatch patterns
- **Parameters**: `matrix_size: Literal[2, 4, 8, 16]`

### 3. Error Diffusion Dithering
Multiple algorithms that propagate quantization error to neighboring pixels:

#### Floyd-Steinberg (Most Common)
- Error distribution: 7/16 right, 3/16 bottom-left, 5/16 bottom, 1/16 bottom-right
- Most widely used, good balance of quality and speed

#### Jarvis-Judice-Ninke
- 12-pixel error distribution
- Higher quality but slower

#### Stucki
- 12-pixel distribution, different weights
- Good for high-detail images

#### Atkinson
- Distributes only 75% of error (lighter appearance)
- Good for high-contrast images

#### Burkes
- 7-pixel distribution
- Faster than Jarvis but better than Floyd-Steinberg

#### Sierra
- Multiple variants (Sierra, Sierra-2-row, Sierra-Lite)
- Different tradeoffs between quality and speed

#### Parameters for Error Diffusion
- `algorithm: Literal["floyd_steinberg", "jarvis", "stucki", "atkinson", "burkes", "sierra", "sierra_2row", "sierra_lite"]`
- `serpentine: bool = False` (bidirectional scanning to reduce artifacts)

### 4. Pattern Dithering
- **Method**: Use predefined patterns for different gray levels
- **Pros**: Predictable results
- **Cons**: Very visible patterns
- **Parameters**: `pattern_size: int`

### 5. Void-and-Cluster Dithering
- **Method**: Blue-noise dithering that minimizes low-frequency noise
- **Pros**: Visually pleasing, no visible patterns
- **Cons**: More complex to implement
- **Parameters**: `cluster_size: int`

## Implementation Architecture

### Main Transform Class

```python
class Dithering(ImageOnlyTransform):
    """Apply dithering to reduce color depth of images.

    Args:
        method: Dithering algorithm to use
        n_colors: Target number of colors per channel (2 for black/white)
        color_mode: How to handle color images ("rgb", "per_channel", "grayscale")
        error_diffusion_algorithm: Specific algorithm for error diffusion method
        bayer_matrix_size: Size of Bayer matrix for ordered dithering
        serpentine: Use serpentine scanning for error diffusion
        p: Probability of applying transform
    """

    class InitSchema(BaseTransformInitSchema):
        method: Literal["random", "ordered", "error_diffusion", "pattern", "void_cluster"]
        n_colors: int = Field(ge=2, le=256)
        color_mode: Literal["rgb", "per_channel", "grayscale"] = "per_channel"
        error_diffusion_algorithm: Literal["floyd_steinberg", "jarvis", "stucki", "atkinson", "burkes", "sierra", "sierra_2row", "sierra_lite"] = "floyd_steinberg"
        bayer_matrix_size: Literal[2, 4, 8, 16] = 4
        serpentine: bool = False
        noise_range: tuple[float, float] = (-0.5, 0.5)
```

### Functional Implementation Structure

Create `albumentations/augmentations/pixel/dithering_functional.py`:

```python
# Core quantization functions
def quantize_colors(img: np.ndarray, n_colors: int) -> tuple[np.ndarray, np.ndarray]:
    """Quantize image to n colors, return quantized and palette"""

# Individual algorithm implementations
def random_dither(img: np.ndarray, n_colors: int, noise_range: tuple[float, float]) -> np.ndarray:
    """Random noise dithering"""

def ordered_dither(img: np.ndarray, n_colors: int, matrix_size: int) -> np.ndarray:
    """Ordered dithering with Bayer matrix"""

def floyd_steinberg_dither(img: np.ndarray, n_colors: int, serpentine: bool) -> np.ndarray:
    """Floyd-Steinberg error diffusion"""

# ... other error diffusion algorithms ...

def generate_bayer_matrix(size: int) -> np.ndarray:
    """Generate Bayer threshold matrix of given size"""

# Error diffusion kernels as constants
FLOYD_STEINBERG_KERNEL = np.array([
    [0, 0, 7/16],
    [3/16, 5/16, 1/16]
])

JARVIS_KERNEL = np.array([
    [0, 0, 0, 7/48, 5/48],
    [3/48, 5/48, 7/48, 5/48, 3/48],
    [1/48, 3/48, 5/48, 3/48, 1/48]
])

# ... other kernels ...
```

## Key Design Decisions

### 1. Color Handling
- **Grayscale conversion**: Convert to grayscale first, then dither
- **Per-channel**: Dither each RGB channel independently
- **RGB together**: Treat as single color space (for palette-based dithering)

### 2. Data Type Handling
- Use `@float32_io` decorator since dithering works with continuous values
- Input can be uint8 or float32, output maintains input type
- Internal processing in float32 [0, 1] range

### 3. Performance Optimizations
- Pre-generate and cache Bayer matrices
- Use NumPy vectorization where possible
- For error diffusion, consider Numba JIT compilation for inner loops
- Implement serpentine scanning efficiently

### 4. Edge Cases
- Handle image borders correctly in error diffusion (don't propagate outside bounds)
- Ensure n_colors=2 produces proper black/white output
- Handle already-quantized images gracefully

## Testing Strategy

### Unit Tests
1. Test each dithering method independently
2. Verify output has correct number of unique values
3. Test with different image sizes and types
4. Test edge cases (single color images, gradients)

### Visual Tests
1. Create gradient test image to show banding reduction
2. Test on photographic images
3. Compare different algorithms side-by-side

### Parameterized Tests
```python
@pytest.mark.parametrize("method", ["threshold", "random", "ordered", "error_diffusion"])
@pytest.mark.parametrize("n_colors", [2, 4, 16, 256])
@pytest.mark.parametrize("img_dtype", [np.uint8, np.float32])
def test_dithering_methods(method, n_colors, img_dtype):
    # Test implementation
```

## Example Usage

```python
import albumentations as A
import numpy as np

# Create transform
transform = A.Compose([
    A.Dithering(
        method="error_diffusion",
        n_colors=2,  # Black and white
        error_diffusion_algorithm="floyd_steinberg",
        color_mode="grayscale",
        p=1.0
    )
])

# Apply to image
image = np.random.randint(0, 256, (100, 100, 3), dtype=np.uint8)
dithered = transform(image=image)["image"]
```

## Implementation Priority

1. **Phase 1** (Core):
   - Floyd-Steinberg error diffusion (most common)
   - Ordered dithering with Bayer matrix
   - Random dithering

2. **Phase 2** (Extended):
   - Other error diffusion algorithms
   - Serpentine scanning

3. **Phase 3** (Advanced):
   - Void-and-cluster method
   - Pattern dithering
   - Color palette optimization

## References

- Wikipedia: Dither - https://en.wikipedia.org/wiki/Dither
- Floyd-Steinberg dithering algorithm details
- Bayer matrix generation algorithms
- Error diffusion kernel specifications

## Notes for Implementation

- Follow AlbumentationsX coding guidelines (no "Random" prefix, use ranges for parameters)
- Implement in `albumentations/augmentations/pixel/` directory
- Add comprehensive docstrings with visual examples
- Consider creating a separate module if implementation becomes large
- Ensure compatibility with existing pipeline (Compose, etc.)
